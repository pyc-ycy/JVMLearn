- 运行时数据区由 `方法区、堆、程序计数器、本地方法栈和虚拟机栈`几大部分构成。

# 一、概述

## 1、JVM 内存布局

- 经典的 JVM 内存布局如下图：

    <img src="./imgs/02.jpg">

- 向上与类加载器子系统交互，向下与执行引擎和交互，并向下提供本地方法接口和本地方法库。JVM 内存具体划分如下图：

    <img src="./imgs/03.jpg">

- JVM 定义了若干程序运行期间会使用到的运行时数据区，其中有一些会随虚拟机的启动而创建，并随着虚拟机的退出而销毁；而另外一些则与线程一一对应，它们会随着线程的开始和结束而创建和销毁。
- 其中方法区和堆空间中的数据是共享的，多个线程之间可以相互访问；而PC计数器、本地方法栈和虚拟机栈中的数据都是非共享的、线程独占一份。因此，垃圾回收或者说JVM调优都是针对方法区和堆进行的。
- 每个 JVM 实例只有一个 Runtime 实例

## 2、Java 线程

- Hotspot JVM 中，每个线程都与操作系统的本地线程直接映射：当一个 Java 线程准备就绪执行后，操作系统同时创建一个对应的本地线程；当 Java 线程执行完成和终止，操作系统就会将对应的本地线程回收。
- 操作系统负责所有线程的安排调度到CPU中，一旦本地线程初始化成功，它就会调用Java线程中的run()方法。
- JVM 线程分为 `守护线程和普通线程`， 当一个 JVM 实例（进程）只要还有普通线程在执行，那么操作系统就不会回收 JVM 实例；而如果只剩下守护线程，则操作系统会将 JVM 实例终止。具体分类，则 Hotspot JVM 里的守护线程——后台线程（不包括public static void main(String[])线程）主要分为：

    1）虚拟机线程：当 JVM 达到安全点才生成。这些操作必须在不同的线程中发生的原因，是它们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-world”的垃圾收集、线程栈收集、线程挂起和偏向锁撤销。

    2）周期任务线程：时间周期事件的体现，一般用于周期性的调度执行。

    3）GC 线程：对在 JVM 里不同种类的垃圾收集行为提供了支持。

    4）编译线程：在 java 程序运行时将字节码文件编译成本地代码。

    5）信号调度线程：接收信号并发送给 JVM，在它内部通过适当的方法进行处理。

# 二、PC 寄存器

- JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。与物理 PC 寄存器一样，JVM 的 PC 寄存器也是用于存储下一条指令的地址；任何时刻只要线程中有一个方法在执行，即所谓的 `当前方法`，JVM PC 寄存器都会存储当前线程正在执行的方法的 JVM 指令地址；或者线程中在执行 native 方法，则 JVM PC 寄存器的值为未指定值（undefine)。
- PC 寄存器是程序流程控制所必须的，也是 Java 虚拟机规范中没有规定任何 `OutOtMemeryError` 情况的区域。

- 示例：

    <img src="./imgs/04.jpg">

- 最左的数字即指令地址或偏移地址，之后是操作指令。
- 关于 JVM PC 寄存器的两个常见的面试问题：

    1）使用 PC 寄存器存储字节码指令地址有什么用？为什么使用 PC 寄存器记录当前线程的执行地址？
    
     因为 CPU 需要不停切换线程，返回时需要知道接着执行哪条指令，而 PC 寄存器的值明确指出下一条的指令地址。

    2）PC 寄存器为什么被设定为线程私有？

    避免线程执行步骤出错，

# 三、虚拟机栈

## 1、概述

- 虚拟机栈的出现，是由于 Java 指令是基于栈的，为了跨平台的需要。栈式运行时单位，堆是存储单位；即栈解决程序的运行问题，堆解决程序的存储问题。每个 Java线程都有一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的 Java 方法调用，是线程私有的。主管线程的运行，保存方法的局部变量（8种基本数据类型变量、对象的引用地址）、部分结果，并参与方法的调用和返回。虚拟机栈只有进栈和出栈操作，无需垃圾回收处理，但存在溢出问题
- JVM 允许虚拟机栈的大小是动态或静态的，对于后者可能存在栈溢出（StackOverError），而前者由于无限扩展可能导致超出内存大小发生内存溢出（OutOfMemoryError）异常。
- 开发者通过使用参数 `-Xss` 选项可以设置最大栈空间，而栈空间决定了函数调用的最大可达深度；例如：-Xss256k。

## 2、栈帧

- 栈帧是虚拟机栈的存储单位；栈帧是一个内存区，是一个数据集，维系着方法执行过程中的各种数据信息。方法和栈帧是一一对应的，方法调用，则栈帧入栈，方法结束则栈帧出栈。在一个活动线程中，一个时间点只会有一个活动的栈帧、有效的栈帧，这个栈帧称之为 `当前栈帧`，其所映射的方法较 `当前方法`，当前方法所归属的类就是 `当前类`；执行引擎运行的所有字节码指令只针对当前栈帧进行操作。不同线程所包含的栈帧是不允许相互引用的。栈帧的退栈可由方法的正常返回以抛出异常触发。
- 代码示例，见 StackFrameTest 类。

### 2.1、栈帧内部结构

- 栈帧由局部变量表（Local Variables）和操作数栈（Operand Stack，表达式栈）、动态链接（Dynamic Linking，指向运行时常量池的方法引用）、方法返回地址（Return Address、方法正常退出或异常退出的定义）以及一些附加信息构成。

    <img src="./imgs/05.jpg">

## 3、局部变量表

- 也称局部变量数组（数字数组）或本地变量表，主要用于存储方法参数和定义在方法体内部的局部变量，数据类型涵盖基本数据类型、对象引用以及 returnAddress 类型。局部变量表大小是在编译时期确定下来的，并保存再方法的 Code 属性的 maximum local variables 数据项中，在运行期间保持不变。
- 参数值的存放从局部变量表的0下标处开始存储，到 -1 结束；局部变量表的基本存储单位是 slot（变量槽），32位以内的数据类型（byte、short、char、boolean-->int）只占用一个slot，64位（long和double）的占两个slot。
- 局部变量表中的变量只对当前方法有效，当方法调用结束后，局部变量表会随着栈帧的出栈而销毁。

## 4、操作数栈

## 5、代码追踪

## 6、栈顶缓存技术

## 7、动态链接

## 8、方法调用：解析与分派

## 9、方法返回地址

## 10、其他

### 1）附加信息

### 2）面试相关
